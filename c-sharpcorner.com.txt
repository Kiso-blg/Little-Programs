https://www.c-sharpcorner.com/UploadFile/puranindia/C-Sharp-interview-questions/


1. Какво е C#?


С# е компютърен език за програмиране. C# е съсзаден от Майкрософт през 2000 година, за да предостави
модерен общ програмен език, който може да бъде използван за разработка на всички видове софтуер насочени
към различни платформи вклщчително Windows, Web, и Mobile използвайки само един програмен език. Днес C# е
един от най-популярните езици за програмиране в света. Милиони софтуерни разработчици използват C# за 
създаване на всякакъв вид софтуер.

C# е основен език за изграждане на Microsoft.NET софтуерни приложения. Разработчиците могат да направят
почти всякакъв вид софтуер използвайки C# включително Windows UI приложения, конзолни приложения, 
бекенд обслужване, облачни APIs, Web услуги, контроли и библиотеки, безсървърни програми, Web приложения,
iOS и Android приложения, AI и софтуер за машинно обучение, blockchain приложения.

Ако искате да прочетете повече за типовете приложения, прочетете тази статия:
https://www.c-sharpcorner.com/UploadFile/mahesh/what-can-C-Sharp-do-for-you/

C# с помощта на Visual Studio IDE осигуряват бързо разработване на приложения. C# е модерен, обектно-ориентиран,
семпъл, гъвкав, ориентиран към повече производителност програмен език. C# е развит базирайки се на най-добрите
свойства и случаи от няколко програмни езика като C++, Java, Pascal и SmallTalk.

Синтаксисът в C# е подобен на C++, а библиотеките в C# са подобни на тези в Java. C# поддържа свойства на 
модерното обектно-ориентирано програмиране като Abstraction, Encapsulation, Polymorphism и Inheritance. C# е 
строго типизиран език и всички типове наследяват класа Object.

C# поддържа концепцията на класове и обекти. Класовете имат елементи като полета, свойства, събития и методи. 
Ето една подробна статия за C# и OOP.
https://www.c-sharpcorner.com/UploadFile/mahesh/what-can-C-Sharp-do-for-you/

C# е гъвкав, модерен, поддържа нуждите на модерното програмиране. От неговото начало C# е минал през много и
различни подобрения. C# 8.0 е последната версия на езика, която се очаква да излезне тази година. Прочетете тази
статия за някои от най-новите свойства на езика C#.
https://www.c-sharpcorner.com/article/c-sharp-7-0-and-c-sharp-7-1-new-features-part-two/


2. Какво е обект в C#? Класовете са основата на C#. 


C# е обектно-ориентиран програмен език. Класът определя как ще изглежда една структора от данни, как ще се 
съхранява, управлява, и прехвърля. Класът има полета, свойства, методи и други членове. 

Докато класовете са идеи, обектите са реални. Обектите се създават чрез исползване на инстанции от класа.
Класът дефинира типа на обекта. Обектите съхраняват реални стойности в паметта на компютъра.

Всяка реална еденица, която може да има характеристики или може да изпълнява дадена работа се нарича Object.  
Този обект също така се нарича инстанция, т.е. копие на реална еденица в програмния език. Обектите са инстанции
на класове.

На пример, трябва да направим програма, която търгува с коли. Трябва да направим единица за кола. Нека го наречем
класът Car. Колата има 4 свойства, т.е., модел, тип, цвят и размер. 

За да представим колата в програмирането, ние можем да създадем класа Car с неговите четири свойства, Model, Type,
Color и Size. Те се наричат членове на класа. Класът има няколко типа от членове, конструктори, полета, свойства,
методи, делегати и събития. Един член на класа може да бъде, private, protected и public. След като тези свойства
могат да са преглеждани извън класа, те трябва да са public. 

Обектът е инстанция на клас. Класът може да има толкова инстанции, колкото е необходимо. Например Honda Civik е 
инстанция на класа Car. В реалното програмиране, Honda Civik е обект. Honda Civik е инстанция на класа Car. Свойствата
Model, Type, Color, Size на Honda Civik са съответно Civik, Honda, Red, 4. BMW 330, Toyota Carolla, Ford 350 Honda CR4,
Honda Accord и Honda Pilot са примерни обекти на класа Car.

За да научите повече реални примери за обекти и инстанции, моля прочетете следния линк:
https://www.c-sharpcorner.com/UploadFile/cda5ba/object-oriented-programming-with-real-world-scenario/


3. Какво е управляван и неуправляван код?


Управляван код:

Представлява код, който е разработен чрес платформата .NET Framework и нейните поддържани програмни езици като C# или
VB.NET. Управляваният код се изпълнява директно от Common Language Runtime (CLR или Runtime) и неговия живот включително
създаването на обекти, разпрелелението в паметта и премахването на обекти се управлява от изпълнителя. Всеки език, 
който е писан на .NET framework e управляван код.

Неуправляван код:

Код, който е разработен извън .NET Framework е познат като неменажиран код.

Приложения, които не се стартират под контрола на CLR са наричани неменажирани. Езиците като C или C++, или Visual Basic
са неменажирани. Създаването на обекти, изпълнението и премахването в неменажирания код се управлява директно от 
програмистите. Ако програмистите пишат некачествен код, това може да доведе до изпускане на памет и нежелано 
разпределение на ресурсите.

.NET Framework осигорява механизъм за неменажиран код да стане менажиран и обратно. Процесът се извършва с помощта на
класа Wrapper. 

Тук има детайлна статия за управляван и неуправляван код:
https://www.c-sharpcorner.com/uploadfile/puranindia/managed-code-and-unmanaged-code-in-net/


4. Какво е Boxing и Unboxing в C#.


Боксинг и Ънбоксинг се използват за преобразуване на типове.

Процесът на преобразуване от тип със стойност на референтен тип се нарича boxing. Боксингът е скрито преобразуване.
Ето пример за боксинг в C#:

//Boxing
int anum = 123;
Object obj = anum;
Console.WriteLine(anum);
Console.WriteLine(obj);

Процесът на преобразуване от референтен тип към тип със стойност се нарича unboxing. Ето пример за ънбоксинг в C#:

//Unboxing
Object obj2 = 123;
int anum2 = (int)obj2;
Console.WriteLine(anum2);
Console.WriteLine(obj2);

Проверете тези две статии, за да научите повече за боксинг и ънбоксинг:
https://www.c-sharpcorner.com/article/boxing-and-unboxing-in-C-Sharp/
https://www.c-sharpcorner.com/uploadfile/puranindia/type-conversions-in-C-Sharp/


5. Каква е разликата между struct и class в C#?


И двете class и struct са дефинирани от потребителя типове данни, но имат няколко основни разлики.
 
Struct
 
Struct е стойностен тип в C# и наследява от System.Value Type.
Struct обикновено се използва за по-малки капацитети от данни.
Struct не може да бъде наследяван от други типове данни.
Структурата не може да бъде абстрактна.
Не е нужно да създаваш обект с нова ключова дума.
Не може да създава какъвто и да е конструктор по подразбиране.

Class

Class-ът е референтен тип данни в C# и наследява от System.Object Type.
Класовете обикновено се използват за голям капацитети от данни.
Класовете могат да бъдат наследявани от други класове.
Класът може да бъде абстрактен тип.
Класът може да създава конструктор по подразбиране.

Прочетете следните статии, за да научите повече за разликата между struct-ожете и класовете:
https://www.c-sharpcorner.com/UploadFile/yougerthen/what-really-make-difference-between-structures-and-classes/
https://www.c-sharpcorner.com/UploadFile/yougerthen/what-really-make-difference-between-structures-and-classes/


6. Каква е разликата между интерфейс и абстрактен клас в C#? 


Ето няколко от общите разлики между интерфейс и абстрактен клас в C#.

Класът може да изпълнява неограничен брой интерфейси, но подкласа само един абстрактен клас.
В абстрактния клас може да има неабстрактни методи (конкретни методи) докато при интерфейса всички методи са абстрактни.
Абстрактния клас може да декларира или използва всякакви променливи, докато при интерфейса не е позволено.
В абстрактния клас всички членове или функции са частни (private) по подразбиране, докато при интерфейса те са 
публични (public). Не можем да ги променяме ръчно.
В абстрактния клас е необходимо да използваме думата abstract, за да декларираме абстрактен метод, докато при
интерфейса не е необходимо да го правим.
Абстрактния клас не може да бъде наследяван многократно, докато интерфейсът може да бъде наследяван многократно.
Абстрактния клас използва конструктор, докато при интерфейса не е необходимо да се използва конструктор.

За да научите повече за разликата между абстрактния клас и интерфейса, посетете следните статии:
https://www.c-sharpcorner.com/uploadfile/prasoonk/abstract-class-vs-interface/
https://www.c-sharpcorner.com/UploadFile/c210df/explore-interface-vs-abstract-class/


7. Какво е енумерация (enum) в C#?

Енумерацията е тип стойност, която съдържа група от сродни именовани константи, често посочвана като списък с енумерации.

Типът на енумерацията може да бъде цяло число (float, int, byte, double и т.н.), но за да се използва вместо int,
трябва да бъде излъчена.

Енумерацията се използва за създаване на числови константи в .NET Framework. Всички членове на енумерацията са от
тип enum. Те трябва да бъдат числови стойности за всеки тип енумерация.

Основният тип по подразбиране в енумерационния елемент е int. По подразбиране първият енумератор има стойност 0 и
стойността на всеки следващ енумератор се увеличава с 1.

enum DoW {Sat, Sun, Mon, Tue, Wed, Thu, Fri};

Няколко точки за енумерацията.

Енумерациите са изброени типове данни в C#.
Енумерациите не са за крайния потребител. Те са предназначени за разработчиците.
Енумерациите са строго типизирани константи. Те са строго типизирани, т.е. енумерация от един тип не може да бъде
имплицитно възложена на енумерация от друг тип, независимо дали основните стойности на тяхните членове са еднакви.
Енумерациите правят вашия код много по-четим и разбираем.
Стойностите на енумерациите са фиксирани. Енумерациите могат да бъдат показани като string и обработени като цяло число.
Типът по подразбиране е int, а другите възможни типове са byte, sbyte, short, ushort, uint, long, ulong.
Всеки енумерационен тип автоматично наследява System.Enum следователно ние можем да изполсваме методите на 
System.Enum на енумерациите.
Енумерациите са стойностни типосе и се създават в стека, а не в heap-а.

За повече подробности, последвайте линковете:
https://www.c-sharpcorner.com/UploadFile/puranindia/enum-in-CSharp/
https://www.c-sharpcorner.com/UploadFile/3d39b4/enumeration-in-C-Sharp/


8. Каква е разликата между операторите "continue" и "break" в C#?


Използвайки оператора break можете да "скочите извън цикъла" (да прекъснете цикъла) докато инползвайки оператора 
continue, можете да проскочите една итерация и да продължите изпълнението на цикъла.

Оператора break пример:
public static void main(String[] args)
{  
    for (int i = 0; i <= 5; i++)
	{  
        if (i == 4) 
		{  
            break;  
        }  
        Console.WriteLine("The number is " + i);  
        Console.ReadLine();  
    }  
} 

Изход
The number is 0; 
The number is 1; 
The number is 2; 
The number is 3;

Оператора continue пример:
public static void main(String[] 
{  
    for (int i = 0; i <= 5; i++) 
	{  
        if (i == 4) 
		{  
            continue;  
        }  
        Console.WriteLine(“The number is "+ i);   
            Console.ReadLine();   
    }  
}  

Изход
The number is 0; 
The number is 1; 
The number is 2; 
The number is 3;
The number is 5;

За повече детайли следвайте линковете:
https://www.c-sharpcorner.com/blogs/difference-between-break-statement-and-continue-statement-in-c-sharp1
https://www.c-sharpcorner.com/UploadFile/2072a9/break-and-continue-statements-in-C-Sharp/


9. Каква е разликата между constant и readonly в C#?


Const е константа, променлива, чиято стойност е постоянна по време на изпълнение. На константата е задължително
да й се придаде стойност.По подразбиране константата е статична и не може да се променя стойността на 
константна променлива по време на цялата програма.

Readonly е ключова дума за променлива, чиято стойност ние можем да променяме по време на изпълнение или
можем да ѝ придадем стойност по време на изпълнение, но само през нестатичен конструктор.

Ето един пример:
Имаме TestClass, в който има две променливи. Едната е readonly, а другата е const.

class Test 
{    
    readonly int read = 10;    
    const int cons = 10; 
	
    public Test() 
	{    
        read = 100;    
        cons = 100;    
    } 
	
    public void Check() 
	{    
        Console.WriteLine("Read only : {0}", read);    
        Console.WriteLine("const : {0}", cons);    
    }    
}

Тук се опитахме да променим стойността на двете променливи в конструктор, но когато се опитахме да променим
константната променлива, даде грешка при смяна на тяхната стойност в блока, който извикахме по време на изпълнение.

Премахнахме този ред от кода на класа и извикахме пак метода Check() със следния код.

class Program 
{    
    static void Main(string[] args) 
	{    
        Test obj = new Test();    
        obj.Check();    
        Console.ReadLine();    
    }    
}    
class Test 
{    
    readonly int read = 10;    
    const int cons = 10; 
	
    public Test() 
	{    
        read = 100;    
    }   
	
    public void Check() 
	{    
        Console.WriteLine("Read only : {0}", read);    
        Console.WriteLine("const : {0}", cons);    
    }    
} 

Научете повече за const и readonly тук:
https://www.c-sharpcorner.com/UploadFile/c210df/difference-between-const-readonly-and-static-readonly-in-C-Sharp/


10. Каква е разликата между ref и out ключови думи?


Ключовата дума ref подава аргумент по референция. Това означава, че всяка промяна на този аргумент в метода
ще се отрази на променливата, когато управлението върне извикания метод.

Ключовата дума out подава аргумент по референция. Подобна е на ключовата дума ref.

Параметърът или аргументът трябва да бъде инициализиран, преди да бъде подаден на ref.
Не е задължително да бъде назначена стойност на параметъра (който е подаден чрез Ref) преди да бъде върнат 
към извикващия метод.
Подавайки стойност на параметъра чрез Ref е полезно, когато извикания метод е необходимо да модифицира
подадения параметър.
Не е задължително, да се инициализира параметър със стойност, преди да бъде използвана от извикващия.
Когато използваме Ref, данните могат да бъдат подадени двупосочно.

Не е задължително да инициализирате параметър или аргумент преди да бъде подаден чрез Out.
Извикания метод е необходимо да назначи или инициализира стойност на параметъра (който е подаден чрез Out)
преди да върне стойност към извикващия метод.
Деклариране на параметър чрес Out е полезно, когато е необходимо няколко стойности да бъдат върнати от
функцията на метода. 
Стойността на параметъра трябва да бъде инициализирана в извикващия метод, преди да бъде използвана.
Когато използваме Out, данните се подават само еднопосочно (от извикания метод към извикващия метод).

И двете Ref и Out се трерират различно по време на изпълнение и се третират еднакво по време на компилация.
Свойствата не са променливи и затова не могат да бъдат подавани като Ref или Out параметър.

За да научите повече за ключовите думи Ref и Out, прочетете следната статия:
https://www.c-sharpcorner.com/UploadFile/ff2f08/ref-vs-out-keywords-in-C-Sharp/


11. Може ли This да бъде използван в статичен метод?


Не можем да изполваме This в статичен метод, защото операторът This връща референция към текущата инстанция на
класа, който я притежава. Статичните методи (или който и да е статичен член) не принадлежат към специфична 
инстанция. Те съществуват без да се създава инстанция към класа и се извикват с името на класа, не по инстанция.
Затова не можем да използваме ключовата дума This в тялото на статичен метод, но в тялото на Extension метод,
можем да използваме This в параметрите на функциите.

Нека хвърлим един поглед към клюяовата дума "this".
Операторът "this" в C# е специален тип референтна променлива, която е имплицитно дефинирана във всеки конструктор 
и нестатичен метод като първи параметър на типа клас, в който е дефинирана.

Научете повече на:
https://www.c-sharpcorner.com/UploadFile/puranindia/this-keyword-in-C-Sharp/


12. Какво са свойствата (Properties) в C#?


Свойствата в C# са членове на класс, които осигуряват гъвкав механизъм на четене, писане, пресмятане на стойности 
на частни полета. С други думи използвайки свойства (properties) можем да достигнем частни полета и да поставим
тяхните стойности. Свойствата в C# са винаги данни на публични членове. Свойствата в C# използват методите 
get и set, известни още като средства за достъп за достигане и назначаване на стойности на частни полета.

Сега въпросът е какво са средствата за достъп?

Get и Set частите или блока от свойства се наричат средства за достъп. Те са полезни за ограничаване достъпа на
свойство. Методът set посочва, че можем да назначим стойност на частно поле в свойство. Без методът set 
свойството е като поле от тип readonly. Чрез методът get можем да достигнем стойността на частно поле, с 
други думи, връща еденична стойност. Операторът get показва, че можем да достигнем стойността на поле публично.

Има три вида свойства в C#. Които можем да четем и записваме стойности, само да четем стойности или само да пишем
стойности. Научете повече тук:
https://www.c-sharpcorner.com/UploadFile/3d39b4/property-in-C-Sharp/


13. Какво са Extension методи в C#?


Extension методите ни позволяват да добавяме методи към съществуващи типове, без да създаваме нови наследени типове,
да прекомпилираме. С други думи, да модифицираме оригиналния тип.

Един Extension метод е специален вид статичен метод, но се извикват сякаш са били истанция на разширения тип.

Как да използваме Extension методи?

Extension методът е статичен метод на статичен клас, където модификаторът "this" е приложен на първия параметър.
Типът на първия параметър ще бъде типът на разширения такъв.

Extension методите в са обсег само, когато изрично въведете namespace-a във вашия програме код чрез директивата using.

За повече детайли на Extension методите може да прочетете тези статии:
https://www.c-sharpcorner.com/uploadfile/puranindia/extension-methods-in-C-Sharp-3-0/
https://www.c-sharpcorner.com/uploadfile/puranindia/extension-methods-in-C-Sharp-3-0/


14. Каква е разликата между методите dispose и finalize в C#?


И двата метода, finalize и dispose се използват, за да освободят неуправляваните ресурси. Ето ги разликите между тях.

Finalize
Finalize се използва, за да освободи неуправлявани ресурси, които не се използват като файлове, връзки с домейна на
базата данни на приложението и други, задържани от обекта преди обекта да бъде унищожен.
Във вътрешните процеси методът бива извикван от Garbage Collector-а и не може да бъде извикан ръчно от потребителя
или други обслужващи услуги.
Finalize принадлежи на класа System.Object.
Прилага се, когато имате неуправлявани ресурси във вашия код. Уверете се, че теси ресурси са освободени, когато
Garbage Collector-а се задейства.

Dispose
Dispose също се използва, за да освободи неуправляваните ресурси, които не се използват като файлове, връзки с 
домейна на базата данни на приложението по всяко време.
Dispose изрично се извиква ръчно чрез кода на потребителя.
Ако трябва да се диспозира метод, трябва да реализираме този клас чрез интерфейса IDisposable.
Dispose принадлежи на интерфейса IDisposable.
Изпълнявайте го, когато пишете потребителски клас, който ще се използва от други потребители.

За повече подробности, последвайте следния линк:
https://www.c-sharpcorner.com/UploadFile/nityaprakash/back-to-basics-dispose-vs-finalize/


15. Каква е разликата между String и StringBuilder в C#?


И двете, StringBuilder и String се използват за работа с низови стойности, но и двете имат много разлики 
базирани на начина на създаване на инстанция и начина на изпълнение.

String
Стрингът е неизменен обект. Неизменен като когато съсзадем нов обект от стринг в кода, ние не можем да модифицираме
или променяме този обект с всякакви операции като да вмъкнем нова стойност, да заменим или прибавим някаква стойност
към съществуващата стойност на стринг обекта. Когато трябва да направим някаква операция да променим един стринг,
то просто ще изхвърли старата стойност на обекта и ще създаде нова инстанция в паметта, където да съхранява новата
стойност на обекта.

class Program
{
	static void Main(string[] args)
	{
		string val = "Hello";
		// create a new string instance instead of changing the old one
		val += " am ";
		val += "Nitin Pandit";
		Console.WriteLine(val);
	}
}

Бележка
Стрингът е неизменен обект, който съдържа низова стойност.
Производителността на стригна е бавна, защото създава нова инстанция, за да презапише или промени предишната стойност.
Стрингът принадлежи към библиотеката System.

StringBuilder
System.Text.StringBuilder е променлив обект, който също съдържа низова стойност. Променлив означава, че веднъж щом 
създадем обект от тип StringBuilder, можем да използваме този обект за много операции като да вмъкнем стойност в
същесвуващ низ с функцията insert. Също така можем да заменим или добавим нова стойност без да се създава всеки път
нова инстанция на обекта. То използва същия (предишния) обект, което го прави бърз в сравнение със System.String.
Нека да разгледаме един пример, за да разберем как работи System.Text.StringBuilder.

class Program
{
	static void Main(string[] args)
	{
		StringBuilder val = new StringBuilder 
		val.Append("Hello");
		val.Append(" I am Nitin Pandit");
		Console.WriteLine(val);
	}
}

Бележка
StringBuilder-а е непостоянен обект.
Производителността на StringBuilder-а е много бърза, защото ще използва инстанцията на същия обект, за да изпълни
всякакви операции като да се вмъкне стойност в съществуващ низ.
StringBuilder принадлежи на библиотеката System.Text.StringBuilder.

За повече детайли прочетете тези статии на следните линкове.
https://www.c-sharpcorner.com/UploadFile/19b1bd/comparison-of-string-and-stringbuilder-in-C-Sharp/
https://www.c-sharpcorner.com/uploadfile/jitendra1987/string-and-stringbuilder-classes/


16. Какво е делегат в C# и каква е ползата от делегатите?


Delegate-ът е абстракция на един или повече функционални показатели (както съществуват в C++; обяснението на това
е извън обхвата на тази статия). .NЕТ е осъществена концепцията на функционалните показатели под формата на 
делетати (delegates). Чрез делегатите може да разглеждате функциите като данни. Делегатите позволяват функциите да
бъдат подадени като параметри, връщат се от функция като стойност и могат да се съхраняват в масив. Делегатите имат следните
характеристики:

Делегатите се наследяват от класа System.MulticastDelegate.
Те имат сигнатура и тип на връщане. Функция, която е подадена към делегат, трябва да бъде съвместима със сигнатурата
на делегата.
Делегатите могат да посочат както статични, така и инстанционни методи.
Веднъж след като е създаден обект тип делегат, той може динамично да извиква методите, към които сочи по време на
изпълнение.
Делегатите могат да извикват методи синхронно и асинхронно.

Делегатите съдържат няколко полезни полета. Първото поле съдържа референция към обекта, а второто съдържа метода показател.
Когато извикате делегат, истанционния метод се извиква според съдържащата референция. Обаче, ако референцията на обекта 
е нула (null), тогава средата на изпълнение разбира това да означава, че методът е статичен. Освен това, извикването на 
делегат синтактично е еднакво като извикването на обикновена функция. Следователно делегатите са идеални за имплементиране
на обратни повикваня.

Защо се нуждаем от делегати?

В исторически план, Windows API често изполсва указатели на функции в стил С, за да суздаде функции за обратно извикване.
Чрез обратно извикване, програмистите могат да конфигурират една функция, да върнат репорт до друга функция в програмата.
Така, че целта на изполване на обратно извикване е да се управляват натискането на бутони, избирането на меню и движението
на мишката. Но проблемът е този традиционен подход е, че функциите за обратно извикване не бяха безопасни. В .NET Framework
обратното извикване е все още осъществимо благодарение на делегатите с много по-ефективен подход. Делегатите запазват три 
важни парчета от информация, както следва:

Параметрите на метода;
Адреса на метода, който извиква;
Типът на връщване, на метода.

Делегатът е решение за ситуации в които искате да подадете метод на други методи. Толкова е обичайно да подавате данни към
метод като параметър, че идеята за подаване на метод като аргумент вместо данни, звучи малко странно. Обаче, в случаи, в които
вие имато метод, който прави нещо, например, извиква друг метод, по време на изпълнение вие не знаете този втори метод какъв е.
Тази информация е достъпна по време на изпълнение. Следователно делегатите са средство за преодоляване на такива усложнения.

Научете повече за делегатите на:
https://www.c-sharpcorner.com/UploadFile/84c85b/delegates-and-events-C-Sharp-net/


17. Какво представляват запечатаните (sealed) класове в C#?


Sealed класовете се използват за ограничаване на наследяваните свойства в обектно ориентираното програмиране. Веднъж класът 
бъде ли дефиниран като sealed клас, той не може да бъде наследяван.

В C# модификаторът sealed се използва за дефиниране на клас като sealed. Във Visual Basic .Net ключовата дума Not Inheritable
служи за запечатване. Ако класът е наследен от запечатан клас, компилаторът хвърля изключение за грешка.

Ако някога сте забелязали, структурите (structs) са запечатани (sealed). Не може да се наследи клас от структора.

Следната дефиниция на клас дефинира запечатан (sealed) клас в C#.
//Sealed class
sealed class SealedClass
{
}

Научете повече за запечатаните класове тук:
https://www.c-sharpcorner.com/article/sealed-class-in-C-Sharp/


18.  Какво представляват частитчните (partial) класове?


Частичния клас се използва само за раделяне на дефинирането на клас, на два или повече класа в сорс кода на един или повече 
файлове. Можете да дефинирате клас на множество полета, но той ще се компилира като един клас по време на изпълнение. Също така
когато дефинирате инстанция на този клас, ще имате достъп до всички методи от целия сорс файл със същия обект.

Частияният клас може да бъде създаден в същото пространство. Не е позволено да се създава частичен клас в различни пространства.
Иползвайте ключовата дума partial с цялото име на класа, който искате да върнете заедно със същото име в същото пространство. 
Нека да видим един пример:

partial class Class1
{
	public void Function1()
	{
		Console.WriteLine("Function 1");
	}
}

partial class Class1
{
	public void Function2()
	{
		Console.WriteLine("Function 2");
	}
}

class Program
{
	static void Main(string[] args)
	{
		Class1 obj = new Class1();
		obj.Function1();
		obj.Function2();
		Console.WriteLine();
	}
}

За да научите повече за частичните класове, погледнете тази статия:
https://www.c-sharpcorner.com/UploadFile/3d39b4/partial-classes-in-C-Sharp-with-real-example/


19. Какво е боксинг и ънбоксинт? (Този въпрос се повтаря)


И двете, боксинг и ънбоксинг, се използват за преобразуване на типове, но имат малко разлики.

Боксинг е процес на преобразуване на стойностен тип данни към обект или някой друг интерфейсен тип данни, който е имплементиран
от този тип стойности. Когато изпълнителя боксва стойност, означава, че изпълнителя преобразува тип със стойност към тип Object.
То обвива стойността вътре в System.Object и я съхранява в купчината на домейна на приложението. Пример:

public void Function()
{
	int i = 111;
	object obj = i; //скрито боксване
	Console.WriteLine(obj);
}

Ънбоксинг е процес, който се използва, за да извлече тип със стойност от тип object или тип на друг имплементиран интерфейс.
Боксването може да се извършва скрито, докато ънбоксинг трябва да бъде изрично чрез кода. Пример:

public void Function()
{
	object obj = 111;
	int i = (int)obj; //изрично ънбоксване
	Console.WriteLine(i);
}

Концепцията на боксването и ънбоксването е в осбовата на обединения изглед на C# на типа система, в която стойността на всеки 
тип може да се третира като обект.

За да научите повече за боксване и ънбоксване, посетете тази статия:
https://www.c-sharpcorner.com/article/boxing-and-unboxing-in-C-Sharp/


20. Какво е интерфейсът IEnumerable<> в C#?


IEnumerable е родителски интерфейс за всички необщи, non-generic колекции в библиотеката System.Collections като ArrayList, Hashtable, 
които могат да бъдат изброени. За всички общи, generic версии на тоси интерфейс е IEnumerable<T>, който е родителски интерфейс всички
generic collections класове в библиотеката System.Collections.Generic в като List<T> и други.

В System.Collections.Generic.IEnumerable<T> има само един метод GetEnumerator(), който връща IEnumerator. IEnumerator осигурява 
възможността да обходим колекция свойството Current и MoveNext, и Reset методи. Ако нямаме този интерфейс като наследяван, няма да 
можем да използваме обхождане като foreach или да използваме този клас в нашата LINQ заявка.

За повече детайли посетете следния линк:
https://www.c-sharpcorner.com/UploadFile/dacca2/implement-ienumerable-interface-in-C-Sharp/



21. Каквоа е разликата между късно свързване и ранно свързване в C#?


Понятията ранно свързване и късно свързване принадлежат към полиморфизма в C#. Полиморфизмът е свойство в обектно ориентираното
програмиране, което позволява езикът да използва едно и също име в различни форми. Например метод Add, който може да добавя integer,
double и децимал.

Има два различни начина да реализираме полиморфизъм:
По време на компилация, също познат като Early Binding или Overloading.
По време на изпълнение, също познат като Late Binding или Overriding.

Полиморфизъм по време на компилация или Early Binding.
Полиморфизъм по време на компилация или Early Binding ще използваме множество методи със същото име, но с различен тип параметър, или
може би брой параметри, благодарение на което можем да изпълним различни задачи със същия метод в същия клас още известно като метод на 
overloading (претоварване).

Вижте как можем да направим това със следния пример:

class MyMath
{
	public int Sum(int val1, int val2)
	{
		return val1 + val2;
	}
	
	public string Sum(string val1, string val2)
	{
		return val1 + " ", + val2;
	}
}

Полиморфизъм по време на изпълнение или Late Binding.
Полиморфизъм по време на изпълнение също познат като Late Binding. Полиморфизъм по време на изпълнение или Late Binding можем да направим
да използваме същите имена на методи, със същата сигнатура, същия тип или същия брой параметри, но не в същия клас, защото компилаторът 
не го ползволява по време на компилация. Затова можем да използваме наследен клас, който го свързва по време на изпълнение, когато ще се
инстанцира класът наследник или наследения обект на класа. Затова го наричаме късно свързване или Late Binding. За целта трябва да създадем
родителски функции на родителския клас като partial и в класа наследник да презапишем тези функции с ключовата дума override. Като в следния
пример.

class Class1
{
	public virtual string TestFunction()
	{
		return "Hello";
	}
}

class Class2 : Class1
{
	public override string TestFunction()
	{
		return "Bye Bye";
	}
}

class Program
{
	static void Main(string[] args)
	{
		Class2 obj = new Class2();
		Console.WriteLine(obj.TestFunction());
		Console.ReadLine();
	}
}

За повече информация:
https://www.c-sharpcorner.com/UploadFile/ff2f08/understanding-polymorphism-in-C-Sharp/
https://www.c-sharpcorner.com/UploadFile/mkagrahari/polymorphism-in-net/


22. Каква е разликата между IEnumerable и IQueryable?


Преди да тръгнем да разглеждаме разликите, нека първо да видим какво представляват IEnumerable и IQueryable.

IEnumerable
IEnumerable е родителският интерфейс на всички неродови (non-generic) колекции в библиотеката System.Collections като ArrayList, Hashtable и т.н.,
които могат да бъдат изброени. За родовите колекции, версия на този интерфейс е IEnumerable<T>, който е родителски интерфейс на всички родови (generic)
колекции в библиотеката System.Collections.Generic като List<T> и други.

IQueryable
Съгласно MSDN IQueryable интерфейсът е предназначен за изпълнение от доставчици на заявки. Предполага се, че се изпълнява от доставчици, които също 
прилагат IQueryable<T>. Ако доставчикът не имплементира IQueryable<T>, стандартният запитващ оператор няма да може да бъде използван върху данните на 
доставчика.

Интерфейсът IQueryable наследява интерфейса IEnumerable така, че ако представлява запитване, резултатът от това запитване може да бъде изброен. 
Изброяването може да причини изпълнението на изразно дърво свързано с IQueryable обект. На пример, може да включи превеждането на изразното дърво
на позходящ език за заявката за основния източник данни. Заявките, които не връшат изброим резултат, се изпълняват, когато методът Execute бъде извикан.

IEnumerable принадлежи към библиотеката System.Collections.
IEnumerable е най-добрия начин да напишете заявка на тип данни от колекции като List, Array и т.е. 
IEnumerable е връщаният тип резултат на заявките LINQ към Object и LINQ към XML.
IEnumerable не поддържа lazy loading. Затова не е препоръчителен подход за променящи се видове сценарии.
Удължени методи подпомагани от IEnumerable взиммат функционални обекти за LINQ заявки.

IQueryable приспада към библиотеката  System.Linq.
IQueryable е най-добрият начин да напишете заявка данни като към отделни база данни, обслужващи колекции и други.
IQueryable е типът връщан резултат на заявки LINQ към SQL.
IQueryable поддържа lazy loading т.е., можем да използваме променящи се видове сценарии.
IQueryable имплементира IEnumerable така, също поддържа удължени методи

https://www.c-sharpcorner.com/UploadFile/a3d5d0/ienumerable-vs-iquerable/
https://www.c-sharpcorner.com/UploadFile/rahul4_saxena/ienumerable-vs-iqueryable/


23. Какво се случва, ако наследените интерфейси имат конфликт в имената на методите?


Ако имплементираме множесто интерфейси на един и същи клас с конфликт в имената на методите, не е нужно да дефинираме всички или с други думи казано,
ако имаме конфликт с методите в един и същи клас, не можем да имплементираме независимо телата на методите заради същото име и сигнатура. Трябва да 
използваме името на интерфейса преди името на метода, за да отстраним този конфликт. Нека да видим пример:

interface TestInterface1
{
	void Show();
}

interface TestInterface2
{
	void Show();
}

class Test : TestInterface1, TestInterface2
{
	void TestInterface1.Show()
	{
		Console.WriteLine("For TestInterface1 !!");
	}
	
	void TestInterface2.Show()
	{
		Console.WriteLine("For TestInterface2 !!");
	}
}

Сега да видим как да използваме този клас:

class Program
{
	static void Main(string[] args)
	{
		TestInterface1 obj1 = new Test();
		TestInterface1 obj2 = new Test();
		obj1.Show();
		obj2.Show();		
	}
}

За повече примери, прегледайте линка:
https://www.c-sharpcorner.com/blogs/inherit-multiple-interfaces-and-they-have-conflicting-method-name1


24. Какво представляват масивите в C#?


В C# индексът на масива започва от нула (0). Това означава, че първия обект в масива се намира на нулева позиция. Позицията на последния обект в масива
е общия брой на обектите - 1. Ако масивът има 10 обекта, последният десети обект ще е на девета позиция.

Масивите могат да бъдат декларирани с фиксирана дължина или динамични.

Масив с фиксирана дължина може да съхранява предварително зададен брой обекти.

Динамичните масиви нямат предварително зададен размер. Размерът на динамичния масив се увеличава като добавяте нови обекти към масива. Можете да 
декларирате масиви с фиксиран размер или динамични. Може дори да промените динамичен масив в статичен, след като е дефиниран.

Нека да разгледаме обикновени декларации на масиви в C#. Следния фрагмент код показва най-обикновения динамичен масив от тим integer, който няма 
фиксирана дължина.

int[] intArrayl

Както може да видите от кода по-горе, декларацията на масив започва с типа на масива последван от квадратни скоби ([]) и име на масива.
Следният фрагмент код декларира масив, който може да съхранява 5 обекта, започващи от 0 до 4.
int[] intArray;
intArray = new int[5];

научете повече за масивите на:
https://www.c-sharpcorner.com/article/working-with-arrays-in-C-Sharp/


25. Какво е конструкторна верига (Constructor Chaining) в C#>


Конструкторна верига е начин на свързване на два или повече класове във връзка като наследяване. В конструкторната верига всеки конструктор на дъщерния
клас е свързан с конструктора на родителския клас чрез ключовата дума base. Когато създадете инстанция на дъщерния клас, той не може да извика конструктора
на родителския клас без наследяване.

За повече примери последвайте линковете:
https://www.c-sharpcorner.com/UploadFile/825933/constructor-chaining-in-C-Sharp/
https://www.c-sharpcorner.com/article/constructors-in-C-Sharp/


26. Каква е разликата между Array.CoppyTo() и Array.Clone()?


Методът Array.Clone() създава повърхностно копие на масив. Повърхностното копие на масива копира само елементите от масива, независимо дали са референтен
тип или стойностен тип, но не копира обектите, към които се отнасят референциите. Ререфенциите в новия масив посочват същите обекти, към които сочат и 
референциите в оригиналния масив.

Статичният метод Array.CoppyTo() от класа Array копира част от масива на друг масив. Методът CoppyTo() копира всички елементи от масива на друг едномерен
масив. Кодът посочен в Listing 9 копира съдържанието на целочислен масив в масив от тип object.

научете повече за масивите тук:
https://www.c-sharpcorner.com/article/working-with-arrays-in-C-Sharp/


28. Може ли многократно да се изпълняват Catch-блокове в C#?


Можем да използваме многократно catch-блокове чрез конструкцията Try-Catch. Всеки catch-блок може да прихваща различно изключение. Следният примерен код показва
как да имплементираме множество catch условия в едно единствено try изявление.

using System;

class MyClient
{
	public static void Main()
	{
		int x = 0;
		int div = 0;
		
		try
		{
			div = 100 / x;
			Console.WriteLine("Not executed line");
		}
		catch (DivideByZeroException de)
		{
			Console.WriteLine(DivideByZeroException);
		}
		catch (Exception ee)
		{
			Console.WriteLine(Exception);
		}
		Finally (DivideByZeroException de)
		{
			Console.WriteLine(Finnally Block);
		}
		Console.WriteLine(Result is {0}), div;
	}
}

За да научите повече за хващането на изключение, моля посетете:
https://www.c-sharpcorner.com/article/exception-handling-in-C-Sharp/


28. Какво представлява дизайн моделът Singleton и как да го имплементираме?


Какво е Singleton Design Pattern?

1. Гарантира, че класът има само една инстанция и осигурява глобална точка за достъм към него.
2. Singleton е клас, който позволява да бъде създадена една единствена инстанция към самия него. Обикновено дава лесен достъп до тази инстанция.
3. Най-често Singleton не позволява каквито и да е параметри да бъдат уточнени при създаване на инстанция, след като повторна заявка за инстанция
с различни параметри може да създаде проблем. (Ако една и съща инстанция трябва да бъде достъпна за всички заявки със същия параметър, тогава
Factory моделът е по-подходящ.)
4. Има различни начини за имплементация на модела Singleton. Следните са общите характеристики на моедла Singleton:
	Единичен конструктор, който е частен и без параметри.
	Класът е sealed.
	Статична променлива, която съдържа референцията към единична създадена инстанция, ако има такава.
	Public static означава получаването на референция кум единично създадената такава, създава такава, ако е необходимо.
	
Следва пример как да напишем код със Singleton:

namespace SingletonDesignPatternExample
{
    class Program
    {      
        static void Main(string[] args)
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

            Calculate.Instance.ValueOne = 10.5;
            Calculate.Instance.ValueTwo = 5.5;
            Console.WriteLine("Addition : " + Calculate.Instance.Addition());
            Console.WriteLine("Substraction : " + Calculate.Instance.Substraction());
            Console.WriteLine("Multiplication : " + Calculate.Instance.Multiplication());
            Console.WriteLine("Division : " + Calculate.Instance.Division());
            Console.WriteLine("\n----------------------------\n");
            Calculate.Instance.ValueTwo = 10.5;
            Console.WriteLine("Addition : " + Calculate.Instance.Addition());
            Console.WriteLine("Substraction : " + Calculate.Instance.Substraction());
            Console.WriteLine("Multiplication : " + Calculate.Instance.Multiplication());
            Console.WriteLine("Division : " + Calculate.Instance.Division());
        }
    }
	
	public sealed class Calculate
    {
        private Calculate()
        {
        }

        private static Calculate instance = null;

        public static Calculate Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new Calculate();
                }
                return instance;
            }
        }

        public double ValueOne { get; set; }

        public double ValueTwo { get; set; }

        public double Addition()
        {
            return this.ValueOne + this.ValueTwo;
        }

        public double Substraction()
        {
            return this.ValueOne - this.ValueTwo;
        }

        public double Multiplication()
        {
            return this.ValueOne * this.ValueTwo;
        }

        public double Division()
        {
            return this.ValueOne / this.ValueTwo;
        }
    }
}

За да научите повече в дълбочина за Singleton, посетете следните линкове:
https://www.c-sharpcorner.com/UploadFile/8911c4/singleton-design-pattern-in-C-Sharp/
https://www.c-sharpcorner.com/UploadFile/b430c7/implementing-singleton-design-patterns/


29. Каква ре разликата между Throw Exception и Throw Clause?


Основната разлика е, че Throw Exception преписва следата на стека и това прави трудно да се намери номера на реда на оригиналния код,
който хвърля изключението.

Throw в основата си запазва информация за стека и добавя към стека информация за изключението, което е върнато.

Вместо да говорим много нека по-добре да видим какво означава това, за по-добро разбиране на разликите. Ще използваме конзолно приложение
за по-лесно тестване, за да видим използването на двете се различава функционално.

namespace TestingThrowException
{
	class Program
	{
		public void ExceptionMethod()
		{
			throw ne Exception("Original Exception occured in ExceptionMethod");
		}
		
		static void Main(string[] args)
		{
			Program p = new Program();
			
			try
			{
				p.ExceptionMethod();
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}
	}
}

Изпълнете кода, за да видите какво се случва. Връща изключение и разгледайте следата на стека.

За да научите повече за хвърлянето на изключения, посетете следния линк:
https://www.c-sharpcorner.com/UploadFile/akkiraju/difference-between-throw-exception-and-throw-clause/


30. Какво представляват индексаторите в C#>

C# въвежда ново понятие като индексатори (Indexers), които се използват за разглеждане на обект като масив. Индексаторите обикновено са 
известни като "умни" масиви. Те не са основна част в обектно-ориентираното програмиране.

Определянето на индексатор ви позволява да създадете клас, който действа като виртуален масив. Инстанциите могат да бъдат достъпни използвайки
оператора за достъп на масив "[]" квадратни скоби.

<modifier>
<return type > this[argument list]
{
	get
	{
		//your get block code
	}
	set 
	{
		//your set block code
	}
} 

В горния код:
<modifier> 
Може да бъде private, public, protected, internal.
<return type>
Може да бъде валиден C# тип.

За да научите повече за индексаторите, послетете линка:
https://www.c-sharpcorner.com/uploadfile/puranindia/indexers-in-C-Sharp/


31. Какво е мултикаст делегат?


Делегатът е един от основните типове в .Net.Delegate. Делегатът е клас, който се използва за създаване и извикване на делегати по време на изпълнение.
Делегатът в C# позволява на разработчиците да разглеждат методи като обекти и да ги извикват от тяхния код.
Пример на имплементация на Multicast Delegates:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

delegate void MDelegate();

class DM
{
	public static void Display()
	{
		Console.WriteLine("Meerut");
	}
	
	public static void Print()
	{
		Console.WriteLine("Roorkee");
	}
}

class Mtest
{
	public static void Main()
	{
		MDelegate m1 = new MDelegate(DM.Display);
		MDelegate m2 = new MDelegate(DM.Print);
		MDelegate m3 = m1 + m2;
		MDelegate m4 = m2 + m1;
		MDelegate m5 = m3 - m2;
		m3();
		m4();
		m5();
	}
}

Научете повече за делегатите в C# тук:
https://www.c-sharpcorner.com/UploadFile/puranindia/C-Sharp-net-delegates-and-events/


32. Каква е разликата между оператора за равенство (==) и метода Equals?


И двата, операторът за равенство и метода Equals() се използват за сравняване на обекти от стойностен тип данни и обекти от референтен тип данни.
Операторът за равенство (==) е оператор за сравение, а методът Equals() сравнява съдържанието на стринг. Операторът за равенство == сравнява еднаквостта
на референцията, докато методът Equals() сравнява само съдържанието. Нека да видим с един пример.

В този пример ние прехвърляме променлива тип стринг към друга променлива. Стрингът е референтен тип и в следващия пример променлива тип стринг е прехвърлена
друга променлива стринг, така, че те сочат към един и същи адрес в купа (heap-а). И двете имам еднакво съдържание, затова получаваме изход True за двата,
операторът за сравнение == и метода Equals().

namespace ComparisonExample
{
	class Program
	{
		static void Main (string[] args)
		{
			string name = "Sandeep";
			string myName = name;
			Console.WriteLine("== operator result is {0}", name == myName);
			Console.WriteLine("Equals() metod result is {0}", name.Equals(myName));
		}
	}
}

За повече детайли отидете на следния линк:
https://www.c-sharpcorner.com/UploadFile/3d39b4/difference-between-operator-and-equals-method-in-C-Sharp/


33. Каква е разликата между оператора "is" и оператора "as" в C#?


Оператора "is"
В езика C# използваме "is" оператора, за да проверим типа на обекта. Ако два обекта са от един и същи тип, връща true, ако не са, връща false.
Нека разгледаме това в нашия C# код. Ще декларираме два класа, Speaker и Author.

class Speaker
{
	public string Name { get; set; }
}

class Author
{
	public string Name { get; set; }
}

class Program
{
	//Нека направим обект тип Speaker
	Speaker speaker = new Speaker() { Name = "Gaurav Kumar Arora" } 
	
	//Сега нека проверим дали обектът е от тип Speaker
	bool isTrue = speaker is Speaker;
	
	//В горния код ние проверяваме дали съвпадат типовете. Да, нашият обект speaker е от тип Speaker
	Console.WriteLine("speaker is of Speaker type: {0}", isTrue);
	
	//Резултатът е True, но в следващия тест имаме резултат False
	
	Author author = new Author() { Name = "Gaurav Kumar Arora" }
	isTrue = author is Speaker;
	Console.WriteLine("author is of Speaker type: {0}", isTrue);
}

Оператора "as"
Операторът "as" се държи по подобен начин като оператора "is". Единствената разлика е, че връща обекта, ако и двата са съвместими с този тип. В
противен случай връща "null".

Нека разгледаме това в нашия C# код.

public static string GetAuthorName(dynamic obj)
{
	Author authorObj = obj as Author;
	return (authorObj != null) ? authorObj.Name : string.Empty;
}

Тук имаме метод, който приема динамичен обект и връща полето "име" на обекта, ако обектът е от тип Author.
Тук декларираме два обекта.

class Program
{
	Speaker speaker = new Speaker() { Name = "Gaurav Kumar Arora" } 
	Author author = new Author() { Name = "Gaurav Kumar Arora" }
	
	//Следният код връща полето "Name"
	string authorName = GetAuthorName(author);
	Console.WriteLine("Author name is: {0}", authorName);
	
	//Тук връща празен стринг
	authorName = GetAuthorName(speaker);
	Console.WriteLine("Author name is: {0}", authorName);
}

Научете повече за операторите "is" и "as" тук:
https://www.c-sharpcorner.com/UploadFile/g_arora/discussing-is-and-as-operators-of-C-Sharp-language/
https://www.c-sharpcorner.com/uploadfile/abhikumarvatsa/the-is-and-as-operators-in-C-Sharp/


34. Как да използваме типове Nullable<> в C#?


Нулевият тип е тип данни, който съдържа данните на дефинирания тип или стойност null. 
Концепцията на нулевия тип не е съвместима с "var".
Всеки тип данни може да бъде деклариран като нулев с помощта на оператора "?".
Например, следващия код декларира int като null.

int? i = null;

Както вече споменахме "var" не е съвместим с нулевите типове. Затова ако декларираме следния код, ще получим грешка.

var? v = null;

За да научите повече за нулевите типове, посетете следния линк:
https://www.c-sharpcorner.com/uploadfile/prasoonk/getting-started-with-nullable-types-in-C-Sharp/


35. Различни начини как може методите да бъдат претоварени.


Overloading на методите е начин да получим полиморфизъм по време на изпълнение, където можем да използваме метод със същото име, но различна 
сигнатура. В следващия примерен код имаме метод Volume с три различни сигнатури базиран на броя и на типоевете на параметрите, и връща стойност.

class Overloading
{
	public static void Main()
	{
		Console.WriteLine(Volume(10));    
		Console.WriteLine(Volume(2.5F, 8));    
		Console.WriteLine(Volume(100L, 75, 15));
	}
	
	static int Volume(int x)
	{
		return (x * x * x);
	}
	
	static double Volume(float r, int h)
	{
		return (3.14 * r * r * h);
	}
	
	static long Volumelong(l, int b, int h)
	{
		return (l * b * h);
	}
}

Бележка:
Ако имаме метод с два параметъра тип object и имаме метод със същото име и два параметъра тип integer, когато извикаме този метод със стойност int,
ще извика метода, който има параметри тип integer, вместо метода с параметри тип object.

Прочетете следната статия, за да научите повече за overloading на методите в C#:
https://www.c-sharpcorner.com/UploadFile/2072a9/method-overloading-in-C-Sharp/


36. Какво представлява обектът Pool в .NET?


Обект Pooling в .NET позволяват на обектите да запазват в паметта запас, и така обектите могат да бъдат преизползвани без да бъдат пресъздавани.

Какво означава това?
Обект Pool е съдържател на обекти, които са готови за използване. Когато има заявка за нов обект, управлението на pool обекта ще вземе тази заявка
и тя ще бъде обслужена чрез разпределение на обект от pool-а.

Как работи?
За тази цел ще трябва да използваме модела Factory. Ще имаме фабричен метод, който ще се грижи за създаването на обекти. Когато има заявка за нов 
обект, фабричният метод ще разгледа съдържателя на обекта (използваме обекта Queue). Ако има наличен обект в позволения лимит, ще върне обекта 
(неговата стойност). В противен случай ще бъде създаден нов обект, и ще бъде върнат обратно.

За да научите повече за Object Pooling и .NET, прочетете следното:
https://www.c-sharpcorner.com/article/object-pooling-in-net/


37. Какво представляват генериците в C#


Генериците позволяват да се забави определянето на типа данни в програмните елементи на клас или метод, докато не бъде използван в програмата. С 
други думи генериците ни позволяват да напишем клас или метод, който може да работи с всеки тип данни.

Спецификациите на клас или метод се пишат с параметър заместител за типа данни. Когато компилаторът се сблъска с конструктора на класа или функцията,
която извиква метода, той генерира код, който да управлява специфичния тип данни.

Генеричните класове и методи комбинират повторна употреба, безопасност на типа и ефективност, която тяхните негенерични дубликати не могат.
Генериците са най-често използвани за работа с колекции и методите, които работят с тях. Версия 2.0 на .NET Framework блиблиотеката осигурява нова
библиотека System.Collections.Generic, която съдържа няколко нови класове с колекции базирани на генерици. Препоръчва се всички приложения насочени към
.NET Framework 2.0 и по-късно, да използват новите класове за генерични колекции вместо по-старите негенерични ответници като ArrayList.

Характеристики на генериците.

Генериците са техника, която обтяга вашето програмиране по следните начини:
Помага ви да максимизирате преизползването на кода, безопасността на типовете и производителността.
Можете да създавате класове с генерични колекции. Библиотеката .NET Framework съдържа няколко генерични колекции с библиотеката System.Collections.Generic.
Можете да използвате тези генерични колекции вместо колециите в библиотеката System.Collections.
Можете да създатете ваш генерични интерфейси, класове, методи и дори делегати.
Можете да създадете генеричен клас заставен да дава достъп на методи с определен тип данни.
Можете да взимате информация за типовете използвани в генеричен тип данни по време на изпълнение използвайки Reflection.

Научете повече за генеричните класове в C# тук:
https://www.c-sharpcorner.com/UploadFile/84c85b/using-generics-with-C-Sharp/


38. Опишете модификаторите за достъп в C#.


Модификаторите за достъп са ключови думи, използвани за уточняване на член или тип.

Модификаторите за достъп са ключови думи, използвани за уточняване обхвата на достъпност на член на тип или на самия обект. Например публичният клас е 
достъпен на целия свят, докато internal класа може да бъде достъпен само от текущата програма.

Защо използваме модификатори за достъп?
Модификаторите за достъп са неделима част от обектно-ориентираното програмиране. Модификаторите за достъп се използват да имплементират капсулация в ООП. 
Модификаторите за доспът ни позволяват да определяме кой може и кой не може да има достъп до определени свойства.

В C# има 6 различни типа модификатори за достъп:
Public - Няма ограничения за достъп на public членове.
Private - Достъпът е ограничен в рамките на дефинирания клас. Това е типът модификатор за достъп, ако друг не е определен.
Protected - Достъпът е ограничен до дефиницията на класа и всеки друг клас, който наследява този клас.
Internal - Достъпът е ограничен единствено и само до класове дефинирани в текъчщия проект.
Protected internal - Достъпът е лимитиран до текущия проект и типовете извлечени от  съдържащия клас. Всички членове в текущия проект и всички членове 
в наследения клас могат да достъпят променливите.
Private protected - Достъпът е ограничен до съдържащия клас или типове наследени от съдържащия клас в конкретния монтаж. 

За да научите повече за модификаторите за достъп:
https://www.c-sharpcorner.com/uploadfile/puranindia/what-are-access-modifiers-in-C-Sharp/


39. Какво представлява Virtual Method в C#?


Виртуалем метод е метод, който може да бъде предефиниран в класове наследници. Виртуалният метод има имплементация в базовия клас, както и в класовете  
наследници. Използва се, когато основната функционалност на метода е същата, но понякога е необходима повече функционалност в класа наследник. Виртуалният
метод се създава в базовия клас и може да бъде надхвърлен от класа наследник. Създаваме виртуален метод в базовия клас изпозлвайки ключовата дума virtual,
и за да надхвърлим метода в класа наследник използвайки ключовата дума override.

Когато методът е деклариран като виртуален метод в базовия клас, тогава методът може да бъде дефиниран в класа наследник и не е задължително класа наследник
да надхвърля този метод. Надхвърления метод също осигурява повече от една форма за метод. Следователно той също е пример за полиморфизъм.

Когато методът е деклариран като виртуален в базовия клас и този метод има същоата дефиниция в класа наследник, тогава не е необходимо да се надхвърля в 
класа наследник. Но когато виртуален метод има различна дефиниция от базовия клас, тогава трябва да бъде надхвърлен в класа наследник.

Когато виртуален метод бива извикан, тогава изпълнитея на типа обект проверява дали има надхвърлен елемент (override member), ако нито един клас наследник
не е надхвърлил този елемент.

По подразбиране методите не са виртуални. Не можем да надхвърлим невиртуален метод.
Не можем да използваме модификатор virtual с модификаторите static, abstract, private или override.

Научете повече за виртуалния метод в C#:
https://www.c-sharpcorner.com/UploadFile/3d39b4/virtual-method-in-C-Sharp/


40. Каква е разликата между Array и ArrayList в C#?


Array използва векторен масив за съхраняване на елементи.
Размерът на Array масива трябва да бъде дефиниран преди използване.
Array съхранява специфичен тип данни.
Няма нужда да се прави кастване към тип.
Не дава грешка по време на изпълнение.
Елементите не могат да бъдат вмъквани или изтривани в масива.
Няма вграден член за подреждане по възходящ или низходящ ред.

ArrayList използва LinkedList за съхраняване на елементи.
Не е нужно да се определя размера за съхранение.
ArrayList може да съхранява всякакви обекти.
Всеки път трябва да се прави кастване към тип.
Може да доведе до грешка по време на изпълнение.
Елементите могат да бъдат вмъквани и изтривани.
ArrayList има много методи за извършване на операции като Sort, Insert, Remove, BinarySearch и други.

Научете повече за масиви, колекции и ArrayList, тук:
https://www.c-sharpcorner.com/UploadFile/skumaar_mca/collections-in-C-Sharp-arraylist-and-arrays/


41. Какво разбирате под стойностни типове и референтни типове в C#?


В C# има два типа данни, стойностни и референтни. Променливите със стойност съдържат тяхния обект или данни директно. Ако копираме една променлива на друга в
същност ние правим копие на обекта на втора променлива. Двете ще оперират независими една от друга с тяхните стойности. Стойностните типове данни се съхранявт
в стек, а референтните типове данни се съхраняват в хийп.

Променливи, които съдържат адрес на друга позиция вместо данни, се наричат референтни променливи. Те включват обекти, класове, интерфейси, делегати и масиви.
Когато инициализираме референтна променлива тя създава хийп в паметта и съхранява там адреса си. Когато копираме референтна променлива към друга променлива,
втората променлива приема адреса, който води към стойността на първата променлива, а не самата стойност. Ако едната променлива бъде променена, втората също ще
бъде променена.

В C# базовите типове данни като int, char, bool, long и други, са стойностни типове. Класове като колекциите и масивите са референтни типове.

За повече детайли последвайте линковете:
https://www.c-sharpcorner.com/UploadFile/ca6c61/concepts-of-C-Sharp-value-type-and-reference-type/
https://www.c-sharpcorner.com/UploadFile/2d4b04/value-types-and-reference-types-variables/


42. Какво е сериализиране в C#?


Сериализирането в C# е процес на преобразъване на обект в поток от битове, за да запази обекта в паметта, база данни или файл. Неговата основна цел е да съхрани
състоянието на обекта с цел да бъде възможно да се пресъздаде, когато е необходимо. Обратният процес се нарича десериализиране.

Ето няколко вида сериализиране:
Binary Serialization - съхранява данните на вашия обект в двоичен формат.
Soap Serialization - съхранява данните на вашия обект в двоичен формат; използва се главно в мрежова комуникажия.
XmlSerialization - съхранява данните на вашия обект в XML файл.

Научете повече за сериализирането тук:
https://www.c-sharpcorner.com/article/serializing-objects-in-C-Sharp/


43. Каква е употребата на оператора "using" в C#?


Има два начина за използване на клюяовата дума using в C#. Единият е като директива, а другият е като израз. Нека да ги обясним.

Using израз
Основно използваме ключовата дума "using", за да добавиме билиотеки в кода и в файловете на класовете. Така стават достъпни всички класове, интерфейси,
абстрактни класове, методите и свойствата на класовете за конкретния клас. Добавянето на библиотека става по следния начин:

using System.Linq;

Using директива
Когато се използва за директива, се създава синоним на библиотека или тип. Ето как се извиква using директива:

using MyProject = TruckingApp.Services;

Научете повече тук:
https://www.c-sharpcorner.com/UploadFile/manas1/usage-and-importance-of-using-in-C-Sharp472/


44. Какво е назъбен масив в?


Назъбеният масив е масив, чиито елементи са масиви. Елементите на назъбения масив могат да бъдат с различни размери. Назъбеният масив понякога е наричан масив от 
масиви.

Специален тип масив е представен в C#. Назъбеният масив  е масив от масив, в който дължината на всеки масив може да е различна. Ето пример:

int[][] jagArray = new int[5][];

В горната декларация редовете са фиксиран размер, но колонките не са определени като може да варират.
Деклариране и инициализиране на назъбен масив:

int[][] jagArray = new int[5][];

//jaggedArray[0] = new int[3];    
//jaggedArray[1] = new int[5];    
//jaggedArray[2] = new int[2];    
//jaggedArray[3] = new int[8];    
//jaggedArray[4] = new int[10];    
jaggedArray[0] = new int[] { 3, 5, 7, };    
jaggedArray[1] = new int[] { 1, 0, 2, 4, 6 };    
jaggedArray[2] = new int[] { 1, 6 };    
jaggedArray[3] = new int[] { 1, 0, 2, 4, 6, 45, 67, 78 };    
jaggedArray[4] = new int[] { 1, 0, 2, 4, 6, 34, 54, 67, 87, 78 };    

Научете повече тук:
https://www.c-sharpcorner.com/UploadFile/puranindia/jagged-arrays-in-C-Sharp-net/


45. Какво е Multithreading в .NET?


Мултитрейдинг позволява програмата да изпълнява няколко операции едновременно. Тази статия обяснява как работи мултитрейдинга в .NET. Тази статия обхваща целия
диапазон на оперираре от thread creation, race conditions, deadlock, muteexes synchronization и semaphores, и други.

Реалното използване на оперирането не е просто еденично последователно опериране, а по-скоро използването на множество операции в една програма. Множество операции
стартирани по едно и също време и изпълняващи различни задачи се нарича мултитрейдинг. Операцията се разглежда като лек процес, защото се стартира в контекста на една
програма и използва ресурсите определени за тази програма.

Еденичният процес съдържа само една операция, докато многооперационния процес съдържа повече от една операции за изпълнение.

За да научите повече за оперирането в .NET, посетете:
https://www.c-sharpcorner.com/UploadFile/84c85b/multithreading-with-net/


46. Обяснете анонимните типове в C#?


Анонимните типове ни позволяват да създадем тип без да го дефинираме. Това е начин да създадем read-only свойство в един обект без да имаме изрично дефиниран тип.
Тук типът се създава от компилатора и е достъпен само за кода от конкретния блок. Типът на свойството също се подразбира от компилатора. 

Можем да създаваме анонимни типове като използваме ключовата дума "new" заедно с инициализирането на обекта. Ето един пример:

var anonymousData = new
{
	ForeName = "Jignesh",
	SurName = "Trivedi"
}

Console.WriteLine("First Name: " + anonymousData.ForeName);

Пример за анонимни типове с LINQ:

Анонимните типове също се използват с клаузата Select в LINQ изразите, за да върнат подмножество от свойства. Ако някоя колекция от обекти има свойсвто наречено FirstName,
LastName, DOB или друго, и ние искаме само FirstName и LastName след заявката на данните, тогава.

class MyData
{
	public string FirstName { get; set; }
	
	public string LastName { get; set; }
	
	public DateTime DOB { get; set; }
	
	public string MiddleName { get; set; }
}

static void Main(string[] args)
{
	List<MyData> data = new List<MyData>();
	data.Add( new MyData {
		FirstName = "Jignesh", LastName = "Trivedi", MiddleName = "G", DOB = new DateTime(1990, 12, 30)
	});
	data.Add( new MyData {
		FirstName = "Tejas", LastName = "Trivedi", MiddleName = "G", DOB = new DateTime(1995, 11, 6)
	});
	data.Add( new MyData {
		FirstName = "Rakesh", LastName = "Trivedi", MiddleName = "G", DOB = new DateTime(1993, 10, 8)
	});
	data.Add( new MyData {
		FirstName = "Amit", LastName = "Vyas", MiddleName = "P", DOB = new DateTime(1983, 6, 15)
	});
	data.Add( new MyData {
		FirstName = "Yash", LastName = "Pandiya", MiddleName = "K", DOB = new DateTime(1983, 6, 15)
	});

	var anonymousData = from pl in data
	select new {
		pl.FirstName, pl.LastName
	};
	
	foreach (var m in anonymousData)
	{
		Console.WriteLine("Name : {0} {1}", m.FirstName, m.LastName);
	}
}

Научете повече за анонимните типове тук:
https://www.c-sharpcorner.com/UploadFile/ff2f08/anonymous-types-in-C-Sharp/
https://www.c-sharpcorner.com/UploadFile/pranayamr/return-anonymous-type-in-C-Sharp/


47. Обяснете Hashtable в C#?


Hashtable е колекция, която съхранява чифтове (ключ и стойност). Ключовете се изполлзват, за да се намери мястото на съхранение и са незаменими, не могат да имат
дубликат в цялата Hashtable. .Net Framework осигурява класа Hashtable, който съдържа всички необходими функции за импементиране на Hashtable без допълнително 
разработване. Хеш таблицата е речникова колекция с общо предназначение. Всеки елемент в колекцията представлява речников запис обект с две свойства, обект ключ и
и обект стойност, известни още като Key/Value. Когато се добавят елементи към хеш таблицата хеш кодът се генерира автоматично. Този код е скрит за разработчиците.
Достъп до стойностите на хещ таблоцата се постига като се използва ключовия обект за идентификация. Елементите в колекцията се съхраняват според скрития хеш код.
Елементите се считат за произволно подредени.

Колекции с хеш таблица.

Основната клас-библиотека, която предостава класа Hashtable е дефинирана в System.Collections и не е необходимо да създавате ваша хещ таблица. Таблицата
обработва всеки ключ от хеша, който добавяте всеки път и тогава използва хеш кода, за да разгледа елемента много бързо. Капацитетът на хеш таблицата е броя на
елементите, които таблицата може да съдържа. Когато са добавени елементи към хеш таблицата, капацитетът ѝ автоматично се увеличава като този процес изисква
прелокализиране.

Декларация на хещ таблица.

Класът Hashtable се намира в библиотеката System.Collections. За да изпълним някой от примерите, трябва да добавим тази колекция към кода. Декларацията е следната:

using System.Collections;

class Program
{
	static void Main(string[] args)
	{
		Hashtable HT = new Hashtable();
	}
}

За да научите повече за HashTable посетете следния линк:
https://www.c-sharpcorner.com/UploadFile/e83792/CSharp-HashTable/


48. Какво е LINQ в C#?


LINQ идва от Language Integrated Query (езикови интегрирани заявки). LINQ е методическо запитване за данни, което осигурява възможности за запитване в .NET 
езиците със синтаксис подобен на SQL заявките.

LINQ дава голяма възможност на запитване на всеки източник данни. Източникът на данни може да бъде колекции от обекти, база данни или XML файл. Можем лесно да
достигнем данни от всеки обект, който импементира интерфейса IEnumerable<T>.

Предимства на LINQ.

1. LINQ предлага обектно-базиран, езико-интегриран начин за запитване към данни, без значение от къде са дошли данните. През LINQ можем да запитваме база данни,
XML файлове както и колекции.
2. Има проверка на синтаксиса по време на изпълнение.
3. Позволява ни да запитваме колекции като масиви, изброими класове и други, в естествения език на вашето приложение, като VB или C# по същия начин както бихте
направили запитване в база данни използвайки SQL.

За повече информация, посетете линковете:
https://www.c-sharpcorner.com/UploadFile/72d20e/concept-of-linq-with-C-Sharp/
https://www.c-sharpcorner.com/UploadFile/84c85b/using-linq-with-C-Sharp-2012/


49. Какво е File Handling в C#?


Библиотеката System.IO предоставя четири класа, които ви позволяват да манипулирате отделни файлове както и взаимодействие със структурата на машинната 
директория. Класовете Directory и File директно разширяват System.Object и поддържат създаване, копиране, преместване и изтриване на файлове, използвайки
различни статични методи. Те съдържат само статични методи и никога не се истанцират. Типовете FileInfo и DirectoryInfo се наследяват от абстрактния клас
FileSystemInfo и са типизирани. Използват се за получаване на пълни детайли на файл или директория, защото техните членове се грижат за връщане на строго
типизирани обекти. Те имплементират почти същите публични методи като Directory и File, но те са динамични и членовете на тези класове не са статични.

За повече информация, последвайте линка:
https://www.c-sharpcorner.com/UploadFile/ajyadav123/file-handling-in-C-Sharp-net/
https://www.c-sharpcorner.com/UploadFile/puranindia/file-handling-in-C-Sharp/


50. Какво е Reflection в C#?


Reflection е процес на откриване на тим по време на изпълнение, при който се разглеждат метаданни CIL код, late-binding и самостоятелно генериращ се код.
По време на изпълнение чрез reflection можем да достъпим същия тип информация, както е показана от помощната програма Ildasm по време на проектиране. Отразяването
е синоним на обърнато инженерство, с което можем да разбием съществуващ *.exe или *.dll механизъм, за да изследваме определено значително съдържание информация,
включително методи, полета, събития и свойства.

Можете динамично да откриете групата от интерфейси, която поддържа даден тип като използвате библиотеката System.Reflection.

Reflection обикновено се използва за изхвърляне на списък с натоварени механизми, тяхната референция за преглеждане на методи, полета и така на татък. Reflection
също се използва за външни разглобяващи инстроменти като Reflector, FxCop и NUnit, защото инструментите в .NET не е необходимо да анализират изходия код подоно
на C++.

Проучване на метаданни.

Следната програма описва процека на отразяването като създава конзолно приложение. Тази програма ще покаже детайлите на полета, методи, свойства и интерфейси за
всеки тип в библиотеката mscorlib.dll. Преди да процедираме е задължително да въведем System.Reflection.

Тук определяме редица статични методи в програмния клас, за да изброим полета, методи и интерфейси в посочения тип. Статичният метод взима параметъра System.Type
и връща void.

static void FieldInvestigation()
{
	Console.WriteLine("*********Fields*********");
	FieldInfo[] fld = t.GetFields();
	
	foreach (FieldInfo field in fld)
	{
		Console.WriteLine("-->{0}", f.Name);
	}
}

static void MethodInvestigation(Type t)
{
	Console.WriteLine("*********Methods*********"); 
	MethodInfo[] mth = t.GetMethods();
	
	foreach(MethodInfo method in mth)
	{
		Console.WriteLine("-->{0}", m.Name);
	}
}

За да научите повече за Reflection, прочетете тези статии:
https://www.c-sharpcorner.com/UploadFile/84c85b/using-reflection-with-C-Sharp-net/
https://www.c-sharpcorner.com/UploadFile/009ee3/reflection-in-C-Sharp/
