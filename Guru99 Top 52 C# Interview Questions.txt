Тук са зададени някои от често използваните въпроси на интервю както за начинаещи и за напреднали разработчици на C# кандидатстващи за работа.

1. КАКВО Е C#?

C# е обектно ориентиран, типо-безопасен и лесно управляван програмен език, който е допълнен с програмната среда .Net Framework, за да състави
програмния език на Майкрософт.

2. ОБЯСНЕТЕ ВИДОВЕТЕ КОМЕНТАРИ В C# С ПРИМЕРИ?

Видовете коментари са:
Единичен ред.
//This is a single line comment.

Множество редове.
/* This is a multiple line comment.
We are in line 2.
Last line of the comment*/

XML коментар.
/// summary;
/// Set error message for multilingual language.
/// Summary

3. МОЖЕ ЛИ НЯКОЛКО CATCH-БЛОКА ДА БЪДАТ ИЗПЪЛНЕНИ?

Не, не могат няколко catch-блока да бъдат изпълнени. Веднъж щом правилния catch код бъде изпълнен, контролът се прехвърля към finally блока
и кодът, който следва, последният finally блок го изпълнява.

4. КАКВА Е РАЗЛИКАТА МЕЖДУ PUBLIC, STATIC И VOID?

Декларираните с public променливи и методи са достъпни навсякъде в приложението. 
Декларираните със static променливи и методи са глобално достъпни без да се създава инстанция на класа. Статичния член по подразбиране не е
глобално достъпен и зависи от типа на модификатора за достъп, който използва. Компилаторът запазва адреса на метода като начална точка и из-
ползва тази информация, за да започне изпълнение преди да бъдат създадени каквито и да е обекти.
Декларираните с void методи или променливи не връщат стойност.

5. КАКВО Е ОБЕКТ?

Обектът е инстанция на класа, чрез която достъпваме методите и полетата на класа. Ключовата дума "New" се използва при създаване на обект.
Клас който създава обект в паметта, ще съдържа информация за методите, полетата и поведението на класа.

6. ДЕФИНИРАЙТЕ КАКВО Е КОНСТРУКТОР?

Конструкторът е функция член на класа, която има същото име като на класа. Конструкторът бива автоматично извикван, когато един клас бъде
създаден. Чрез конструктора се подават стойностите на данните на членовете когато се инициализира класа.

7. КАКВО ПРЕДСТАВЛЯВАТ НАЗЪБЕНИТЕ МАСИВИ?

Масичи, чиито елементи са други масиви, се наричат назъбени масиви. Елементите от други масиви могат да бъдат с различни размери и дължина.
Назъбеният масив също се нарича масив от масиви.

8. КАКВА Е РАЗЛИКАТА МЕЖДУ ПАРАМЕТРИТЕ REF И OUT?

Ключовата дума ref подава аргумент по референция. Това означава, че всяка промяна на този аргумент в метода ще се отрази на променливата,
когато управлението върне извикания метод.

Ключовата дума out също подава аргумент по референция подобно на ключовата дума ref. Извикания метод е необходимо да назначи или инициали-
зира стойност на параметъра, който е подаден чрез out, преди да върне стойност към извикващия метод.

Когато използваме ref, данните могат да бъдат подавани двупосочно.

Когато използваме out, данните се подават само еднопосочно от извикания метод към извикващия.

Аргумент подаден като ref трябва да бъде инициализиран преди подаването към метода, докато аргумент подаден като out не е нужно да бъде ини-
циализиран преди подаването към метода.

9. ЗА КАКВО СЕ ИЗПОЛЗВА ИЗРАЗА "USING" В C#?

Using-блок се иползва, за да вземем данни, да ги обработим и автоматично да прекратим процеса, когато изпълнението на клока приключи.

10. КАКВО Е СЕРИАЛИЗАЦИА?

Когато искаме да пренесем даден обект или данни по мрежата, тогава ние трябва да преобразуваме обекта или данните в поток от байтове. Про-
цесът на преобразуване на обект или данни в поток от байтове се нарича сериализация. За да бъде един обект сериализиран, трябва да се импле-
ментира интерфейсът ISerialize. Обратният процес на създаване на обект или данни от поток от байтове се нарича десериализация.

---

В информатиката, в контекста на съхраняване на данни, сериализацията е процес на преобразуване на структури от данни или обекти до поток от 
байтове запазвайки състоянието на техните полета и свойства. Потокът може да бъде двоичен (binary) или текстов (XML, JsonString). Когато бай-
товете биват прочетени отново чре процеса на десериализация, се създава идентично копие на оригиналния обект.

11. МОЖЕМ ЛИ ДА ИЗПОЛЗВАМЕ КОМАНДАТА "THIS" В СТАТИЧЕН МЕТОД?

Не можем да използваме "this" в статичен метод, защото можем да използваме само статични променливи или статични методи в статичен метод.

12. КАКВА Е РАЗЛИКАТА МЕЖДУ CONSTANT И READ-ONLY?

Константните променливи се декларират и инициализират по време на изпълнение. Стойността им не може да бъде променяна след това.
Read-only се използва, когато искаме да назначим стойност по време на изпълнение.

13. КАКВО ПРЕДСТАВЛЯВАТ "INTERFACE"-КЛАСОВЕТЕ? ДАЙТЕ ПРИМЕР НА ЕДИН ТАКЪВ?

Интерфейсът е абстрактен клас, който има само публични абстрактни методи и полета. Методите и полетата биват само декларирани, бе да им се
дефинира стойност. Абстрактните методи и полета трябв да бъдат дефинирани с в класовете наследници.

namespace DemoApplication
{
	interface IGuru99Interface
	{
		void SetTutorial(int pID, string pName);
		string GetTutorial();
	}
	
	class Guru99Tutorial : IGuru99Interface
	{
		protected int TutrialID;
		protected string TutorialName;
		
		public void SetTutorial(int pID, string pName)
		{
			TutrialID = pID;
			TutorialName = pName;
		}
		
		public string GetTutorial()
		{
			return TutorialName;
		}
	}
	
	static void Main()
	{
		Guru99Tutorial pTutor = new Guru99Tutorial();
		
		pTutor.SetTutorial(1, ".Net by Guru99");
		
		Console.ReadKey(true);
	}
}

14. КАКВО СА СТОЙНОСТНИ ТИПОВЕ И КАКВО СА РЕФЕРЕНТНИ ТИПОВЕ?

Стойностните типове пазят стойност в тяхно собствено пространство памет. Например:

int a = 30;

Референтните типове пазят адреса на обекта, където стойноста му бива съхранена. Те са показател към друго място в паметта. Например:

string b = "Hello Guru99!!";

15. КАКВО Е ПЕРСОНАЛИЗИРАН КОНТРОЛ (CUSTOM CONTROL) И КАКВО Е ПОТРЕБИТЕЛСКИ КОНТРОЛ (USER CONTROL)?

Персонализираните контроли са контроли генерирани като компилиран код (Dlls). Те са по-лесни за използване и могат да бъдат добавени
към кутията с инструменти. Разработчиците могат с drag-and-drop да теглят и пускат контроли към тяхните интернет и други форми. Можем
лесно да добавяме контроли към множество приложения, ако споделят общи библиотеки. Ако те са частни (private) те могат да бъдат копи-
рани в bin-директорията на библиотеката на приложението и тогава да се добави референция, с която ще могат да се използват.

Потребителските контроли са подобни на файловете включващи ASP и са лесни за създаване. Потребителските контроли не могат да бъдат 
сложени в кутията с инструменти и да бъдат изтеглени от там. Те имат техен дизайн и техен код. Разширението на файловете за потре-
бителските контроли е ascx.

16. КАКВО ПРЕДСТАВЛЯВАТ ЗАПЕЧАТАНИТЕ КЛАСОВЕ (SEALED CLASSES) В C#?

Използваме запечатани класове, когато искаме да забраним класът да не може да бъде наследяван. Модификаторът "sealed" се използва, за
да предотврати наследяване от клас. Ако умишлено посочим запечатан клас бато базов клас, тогава ще се почви грешка по време на изпълнение.

17. КАКВО Е "OVERLOADING" НА МЕТОДИТЕ?

Overloading на методите се нарича, когато съсдадем множество методи с еднакво име и уникалниа сигнатура в един и същи клас. Когато ком-
пилираме, компилаторът използва разделителна способност, за да определи специфичния метод, който да бъде извикан.

18. КАКВА Е РАЗЛИКАТА МЕЖДУ "ARRAY" И "LIST<Т>"?

В масива можем да имаме само елементи от един и същи вид. Размерът на масива е фиксиран.
"List<T>" е подобен на масива, с тази разлика, че няма фиксирана дължина.

19. МОЖЕ ЛИ ЧАСТЕН ВИРТУАЛЕН МЕТОД (PRIVATE VIRTUAL METHOD) ДА БЪДЕ ПРЕНАПИСАН?

Не, защото не е достъпен извън класа.

20. ОПИШЕТЕ МОДИФИКАТОРА ЗА ДОСТЪП "PROTECTED INTERNAL"?

Променливите и методите обозначени с "protected internal" са достъпни във същата програма и също могат да бъдат наследявани от основния клас.

21. КАКВА Е РАЗЛИКАТА МЕЖДУУ КЛАСОВЕТЕ "SYSTEM.STRIN" И "SYSTEM.TEXT.STRINGBUILDER"?

Класът "System.String" е неизменим. Когато модифицираме стойност на променлива тип "string", се определя ново място в паметта за новата стой-
ност и предишното място в паметта се освобождава.
Класът "System.StringBuilder" е проектиран да има да бъде непостояннен стринг, на който могат да бъдат извършени разнообразие от операции без
да се определя отделно място в паметта за модифицирания низ.

22. КАКВА Е РАЗЛИКАТА МЕЖДУ System.Array.CopyTo() И System.Array.Clone()?

Използвайки метода Array.Clone() ние създаваме нов обект от тип масив който съдържа всички елементи от оригиналния масив независимо дали са 
стойностен тип или референтен тип, но не копира обекти, които представляват референции. 
Методът Array.CopyTo() копира всички елементи от текущия масив в новосъздаден масив започвайки от определен индекс. Новосъздаденият масив 
трябва да има предварително зададена дължина и трябва да има достатъчен брой от елементи, за да побере копираните елементи.

23. КАК МОЖЕМ ДА СОРТИРАМЕ ЕЛЕМЕТИТЕ В МАСИВ В НАМАЛЯВАЩ РЕД?

Можем да сортираме елементите в масив в намаляващ ред използвайки метода Sort() последван от метода Reverse().

24. НАПИШЕТЕ ПО-ДОЛУ СИНТАКСИСА В C# ЗА ПРИХВАЩАНЕ НА ГРЕШКА.

За да прихванем грешка, използваме блока "try-catch". "Catch"-блока може да има параметър от тип System.Exception. Параметърът в "catch"-
блока може да бъде пропуснат.

try
{
	GetAllData();
}
catch (Exception ex)
{
	Throw ex.Message();
}

25. КАКВА Е РАЗЛИКАТА МЕЖДУ ИНТЕРФЕЙС И АБСТРАКТЕН КЛАС?

Всички методи в интерфеса имат само декларация без дефиниция. 
Всички методи в интерфейса са абстрактни, докато в абстрактния клас може да има неабстрактни методи (монкретни методи).
Всички методи в интерфейса са публични (public), докато в абстрактния клас има само частни (private) методи.
Абстрактния клас може да декларира или използва всякакви променливи, докато при интерфейса не е позволено.
Абстрактния клас не може да бъде наследяван многократно, докато интерфейсът може да бъде наследяван многократно.
Абстрактния клас използва конструктор, докато при интерфейса не е необходимо да се използва конструктор.

26. КАКВА Е РАЗЛИКАТА МЕЖДУ МЕТОДИТЕ Finalize() И Dispose()?

Извикваме метода Dispose(), когато искаме да освободим неуправляваните ресурси на даден обект. От друга страна методът
Finalize() се използва за същата причина, но не гарантира за освобождаването на ресурсите на обекта.

27. КАКВО ПРЕДСТАВЛЯВАТ КРЪГОВИТЕ РЕФЕРЕНЦИИ?

Кръгова референция е ситуация, в която два или повече ресурса са взаимозависими един от друг предизвиквайки заключено състояние и правят
ресурсите неизползваеми.

28. КАКВО ПРЕДСТАВЛЯВАТ ГЕНЕРИЦИТЕ В C#.NET?

Генериците се използват за създаване на кодове за многократна употреба, за да се намали излишността на кода, да се увеличи безопасността
и производителността. Използвайки генерични материали, можем да създадем класове за колекции. За да създадем генерична колекция, трябва 
да използваме пространството System.Collection.Generics. Генериците насърчават използването на параметризирани типове.

29. КАКВО Е "OBJECT POOL" В .NET?

"Obect pool" е контейнер, който има обекти готови да бъдат използвани. Той следи обекта, който в момента се използва и общия брой на 
обекти в "pool"-а. Това редуцира създаването и пресъздаването на обекти.

30. ИЗБРОЙТЕ КОИ СА НАЙ-ЧЕСТО ИЗПОЛЗВАНИТЕ ТИПОВЕ ЗА ГРЕШКИ/ИЗКЛЮЧЕНИЯ В .NET?

Най-често използваните изключения са ArgumentException, ArgumentNullException, ArgumentOutOfRangeException, ArithmeticException,
DivideByZeroException, OverflowException, IndexOutOfRangeException, InvalidCastException, InvalidOperationException,
IOEndOfStreamException, NullReferenceException, OutOfMemoryException, StackOverflowException и други.

31. КАКВО ПРЕДСТАВЛЯВАТ ПЕРСОНАЛИЗИРАНИТЕ ГРЕШКИ/ИЗКЛЮЧЕНИЯ?

Понякога има грешки/изключения, които трябва да бъдат обработени според изискванята на потребителя. За тях се използват персонализирани
грешки/изключения. Те са потребителски дефинирани грешки/изключения.

32. КАКВО ПРЕДСТАВЛЯВАТ ДЕЛЕГАТИТЕ?

Делегатите са подобни на функционалните показатели в C++ с тази разлика, че делегатите са типо-безопасни. Делегатите са полезни, защото 
те могат да бъдат използвани за писането на много генерични типо-безопасни функции.

33. КАК УНАСЛЕДЯВАТЕ КЛАТ ОТ ДРУГ КЛАС В C#?

Двоеточието ":" се използва като оператор за наследяване в C#. Поставя се двоеточие след името на класа.

public class DerivedClass : BaseClass

34. КОЙ Е ОСНОВНИЯ КЛАС В .NET Framework, КОЙТО БИВА НАСЛЕДЯВАН ОТ ВСИЧКИ ДРУГИ КЛАСОВЕ?

System.Object.

35. КАКВА Е РАЛЗЛИКАТА МЕЖДУ "OVERRIDING" МЕТОД И "OVERLOADING" МЕТОД?

В обозначениq с "overriding" метод, можем да променим дефиницията на метотда в класа наследник като така променяме поведението на метода.
Претовареният "overriding" метод е мотод съсзаден в същия клас, чието име съвпада с името на друг метод, но сигнатурата му е различна.

36. КАКВИ СА РАЗЛИЧНИТЕ ВАРИАНТИ, В КОИТО ЕДИН МЕТОД МОЖЕ ДА БЪДЕ ПРЕТОВАРЕН "OVERLOADED"?

Метод може да бъде претоварен използвайки различен тип данни като параметър, различен ред на подреждане на параметрите и раличен брой
параметри.

37. ЗАЩО НЕ МОЖЕМ ДА УТОЧНИМ МОДИФИКАТОРИТЕ ЗА ДОСТЪП В НА МЕТОДИ В ИНТЕРФЕЙСИТЕ?

В интерфейсите имаме жиртуални методи, които нямат дефиниция. Всички методи в интерфейсите биват дефинирани в наследяващите класове. За-
това всички методи са пъблични.

38. КАК МОЖЕМ ДА НАСТРОИМ КЛАС, КОЙТО ДА БЪДЕ НАСЛЕДЯВАН, НО ДА ПРЕДОТВРАТИМ МЕТОДИТЕ МУ ДА НЕ МОГАТ ДА БЪДАТ ПРЕДЕФИНИРАНИ?

Декларираме класа като публичен и правим методите запечатани "sealed", за да предотвратим да не могат да бъдат предефинирани.

39. КАКВО СЕ СЛУЧВА, АКО НАСЛЕДЕНИЯ ИНТЕРФЕЙС ИМА КОНФЛИКТ С ИМЕНАТА НА МЕТОДИТЕ?

Реализацията зависи от нас, тъй като методът методът е в нашия собсвен клас. Може да възникне проблем, когато методи от различни интер-
фейси очакват различни данни, но що се отнася до компилатора, всичко е наред.

40. КАКВА РЕ РАЗЛИКАТА МЕЖДУ STRUCT И CLASS?

Struct са променливи със стойност, а класовете са референтни променливи. Структури съхранени в стека причиняват допълнителни разходи на
ресурси, но извличат данни по-бързо. Структурите не могат да бъдат наследявани.

41. КАК ИЗПОЛЗВАМЕ НУЛЕВИ ПРОМЕНЛИВИ В .NET Framework?

Стойностните типове могат да приемат както нормални стойности, така и нулева стойност. Тези типове се наричат нулеви типове. Ето пример.

int? someID = null;

if (someID.HasValue) //(someID is null)
{
}

42. КАК МОЖЕМ ДА СЪЗДАДЕМ МАСИВ БЕЗ СТОЙНОСТИ ПО ПОДРАЗБИРАНЕ?

Можем да създадем масив без стойности по подразбиране използвайки Enumerable.Repeat.

43. КАКВА Е РАЗЛИКАТА МЕЖДУ ОПЕРАТОРИТЕ "IS" И "AS" В C#?

Операторът "is" се използва, за да провери съвместимостта на един обект с даден тип данни и връща резултата като булева стойност.
Операторът "as" се използва за преобразуване на обект в определен тип или клас.

44. КАКВО Е МНОЖЕСТВЕН ДЕЛЕГАТ (MULTICAST DELEGATE)?

Делегат с два или повече назначени прихващачи/обработчици се нарича множествен делегат. Всеки прихващач/обработчик е назначен към метод.

45. КАКВО ПРЕДСТАВЛЯВАТ ПОКАЗАТЕЛИТЕ (INDEXERS) В C#.NET?

Показателите са извесни като умни масиви в C#. Те позволяват клас да бъде индексиран по същия начин като масив. Ето пример:

public int this[int index] // Indexer declaration

46. КАКВА Е РАЗЛИКАТА МЕЖДУ "THROW" И "THROW EX" В .NET Framework?

Изявлението "throw" запазва оригиналния стек за грешка, докато изявлението "throw ex" има следа в стека от точката на прихващане на греш-
ката. Препоръчително е винаги да се използва "throw" защото до предоставя по точна информация за грешката.

47. КАКВО ПРЕДСТАВЛЯВАТ АТРИБУРИТЕ В C# И КАКВО Е ТЯХНОТО ЗНАЧЕНИЕ?

C# предоставя на разработчиците начин да дефинират декларативни тагове за определени обекти като класове, методи и други. Тези тагове се
наричат атрибути. Информацията в атрибутите може да бъде извлечена по време на изпълнения използвайки "Reflection".

48. КАК ДА ИМПЛЕМЕНТИРАМЕ ДИЗАЙН МОДЕЛЪТ "SINGLETON"?

В моделът "singleton" един клас може да има само една инстанция като осфигурява глобален достъп до нея. Например:

public sealed class Singleton

{
	private static readonly Singleton instance = new Singleton();
}

49. КАКВА Е РАЗЛИКАТА МЕЖДУ "DIRECTCAST" И "CTYPE"?

"DirectCast" се използва, когато искаме да преобразуваме типа на обект, който има изискване по време на изпълнение да бъде от същия тип,
какъвто е посочения тип в "DirectCast"-а.

"Ctype" се използва за преобразуване, когато преоразуването е определено между ираза и типа.

50. КОДЪТ В C# УПРАВЛЯВАН ЛИ Е ИЛИ НЕУПРАВЛЯВАН?

Кодът в C# е управляван тъй като общия изпълнител на езика (Common Language Runtime - CLR) може да компилира C# код в преходен език.

51. КАКВО Е КОНЗОЛНО ПРИЛОЖЕНИЕ?

Конзолно приложение е приложение, което може да бъде стартирано през "Command Prompt" в Уиндоус. За всеки начинаещ в .NET Framework е
идеално, да се започне с изграждане на конзолни приложения като първи стъпки.

52. ДАЙТЕ ПРИМЕР ЗА ПРЕМАХВАНЕ НА ЕЛЕМЕНТ ОТ ОПАШКА (QUEUE)?

Методът .Dequeue се използва за премахването на елемент в опашка (Queue).

namespace DemoApplication
{
	class Program
	{
		static void Main(string[] args)
		{
			Queue<int> qt = new Queue<int>();
			qt.Enqueue(1);
			qt.Enqueue(2);
			qt.Enqueue(3);
			
			foreach (int n in qt)
			{
				Console.WriteLine(n);
			}
			
			Console.WriteLine();
			Console.WriteLine("The number of elements in the Queue " + qt.Count);
			Console.WriteLine("Does the Queue contain " + qt.Contains(3));
			
			qt.Dequeue();
			Console.WriteLine("The number of elements in the Queue " + qt.Count);
			Console.WriteLine("Does the Queue contain " + qt.Contains(3));
			Console.ReadKey(true);
		}
	}
}






























